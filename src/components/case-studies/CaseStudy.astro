---
import Button from '@/components/Button.astro'

interface Props {
  /**
    Default case study data
  */
  data: {
    heading: string
    overline: string
    description: string
    kpis: {
      label: string
      value: string
    }[]
    cta: {
      label: string
      url: string
    }
  }
  /**
    Aspect ratio of the media container
  */
  mediaAspectRatio: string
  /**
    The unique ID for the case study
  */
  id?: string
  /**
    Additional classes to pass to the component
  */
  class?: string
}

const { data, mediaAspectRatio, class: className, id, ...attrs } = Astro.props
---

<article
  class:list={[
    className,
    'group flex w-full flex-col rounded-20 odd:origin-left even:origin-right md:w-[calc(100%+80px)] md:flex-row md:rounded-40 md:odd:-translate-x-80 md:odd:flex-row-reverse',
  ]}
  data-case-study
  id={id}
  {...attrs}
>
  <div
    class="flex flex-col justify-center gap-24 p-32 md:min-w-[450px] md:px-[7vw] md:py-64 xl:px-96"
  >
    <p class="text-sm text-black" data-case-text>{data.overline}</p>
    <div class="space-y-8">
      <h2 class="text-2xl font-bold text-black" data-case-text>
        {data.heading}
      </h2>
      <p data-case-text>{data.description}</p>
    </div>

    <ul class="flex flex-wrap gap-32" data-case-text>
      {
        data.kpis.map(({ label, value }: { label: string; value: string }) => (
          <li class="space-y-8">
            <p class="text-lg font-bold text-black">{value}</p>
            <p class="text-xs">{label}</p>
          </li>
        ))
      }
    </ul>
    <Button
      variant="secondary"
      size="sm"
      class="mt-8"
      label={data.cta.label}
      href={data.cta.url}
      aria-label={`Read the ${data.heading} Case Study`}
      data-case-text
    />
  </div>

  <div class="case__media" style={`aspect-ratio: ${mediaAspectRatio}`}>
    <slot />
  </div>
</article>

<style>
  .case__media {
    @apply relative flex w-full items-center;

    @screen <md {
      @apply -order-1 -mt-32;
    }

    @screen md {
      @apply -my-96 min-w-[650px] max-w-[800px];
    }

    & :global(> *) {
      @apply absolute flex h-full w-full items-center justify-center;

      @screen md {
        @apply min-w-[650px] max-w-[800px] object-contain group-odd:right-0;
      }
    }
  }

  [data-case-study],
  [data-case-text] {
    opacity: 0;

    @media screen and (prefers-reduced-motion: reduce), (update: slow) {
      & {
        opacity: 1;
      }
    }
  }
</style>

<script>
  import { gsap } from 'gsap'
  import { ScrollTrigger } from 'gsap/ScrollTrigger'
  import { mmFilters } from '@/scripts/app.ts'
  import type { AnimatedElement } from '@/scripts/app.ts'

  // only run when there is no preference for reduced motion
  gsap.matchMedia().add(mmFilters, (context) => {
    let { reduceMotion } = context.conditions ?? {}

    const triggers = gsap.utils.toArray(
      '[data-case-study], [data-case-text]',
    ) as AnimatedElement[]

    gsap.set(triggers, { opacity: 0 })

    ScrollTrigger.batch(triggers, {
      start: 'top bottom',
      end: 'bottom top',
      onEnter: (batch) => {
        batch.forEach((el: AnimatedElement, i: number) => {
          setAnimation(el, i)
        })
      },
      onEnterBack: (batch) => {
        batch.forEach((el: AnimatedElement, i: number) => {
          setAnimation(el, i, -1)
        })
      },
      onLeave: (batch) => {
        batch.forEach((el: AnimatedElement) => {
          // kill the timeline when leaving the viewport
          el.timeline?.kill()
          gsap.to(el, { opacity: 0 })
        })
      },
      onLeaveBack: (batch) => {
        batch.forEach((el: AnimatedElement) => {
          // kill the timeline when leaving the viewport
          el.timeline?.kill()
          gsap.to(el, { opacity: 0 })
        })
      },
    })

    function setAnimation(
      el: AnimatedElement,
      index: number = 0,
      direction?: -1 | 1,
    ) {
      direction = direction || 1

      const timeline = gsap.timeline({
        invalidateOnRefresh: true,
        immediateRender: false,
      })

      timeline.fromTo(
        el,
        {
          autoAlpha: 0,
          y: reduceMotion ? 0 : 75 * direction,
          scale: reduceMotion ? 1 : 0.925,
        },
        {
          autoAlpha: 1,
          scale: 1,
          y: 0,
          delay: reduceMotion ? 0 : index * 0.2,
          ease: 'circ.out',
          duration: 1,
          clearProps: 'x,y',
        },
      )

      // store the timeline on the element
      el.timeline = timeline
    }

    ScrollTrigger.addEventListener('refreshInit', () => {
      gsap.set(triggers, { y: 0 })
    })
  })
</script>
